import Pool from "@aave/core-v3/artifacts/contracts/protocol/pool/Pool.sol/Pool.json";
import { createInstance as createFhevmInstance } from "fhevmjs";
import { task, types } from "hardhat/config";

import addresses from "../../../config/addresses";
import { GATEWAY_URL } from "../../../config/constants";
import { AaveConfidentialityAdapter } from "../../../types";

task("getSuppliedBalance", "Get user's supplied balance to Aave")
  .addOptionalParam("signeraddress", "signer address", undefined, types.string)
  .addOptionalParam("contractaddress", "Aave Confidentiality Adapter address", undefined, types.string)
  .addOptionalParam("asset", "The supplied token address", undefined, types.string)
  .setAction(async ({ signeraddress, contractaddress, asset }, hre) => {
    const { getChainId, ethers, deployments, getNamedAccounts } = hre;
    const chainId = await getChainId();
    const { user } = await getNamedAccounts();
    const signer = await ethers.getSigner(signeraddress || user);

    if (!addresses[+chainId]) {
      throw new Error("Chain ID not supported");
    }

    if (!contractaddress) {
      contractaddress = (await deployments.get("AaveConfidentialityAdapter")).address;
    }

    if (!asset) {
      asset = addresses[+chainId].AAVE_USDC;
    }

    const instance = await createFhevmInstance({
      kmsContractAddress: addresses[+chainId].KMSVERIFIER,
      aclContractAddress: addresses[+chainId].ACL,
      networkUrl: hre.network.config.url,
      gatewayUrl: GATEWAY_URL,
    });

    const { publicKey, privateKey } = instance.generateKeypair();
    const eip712 = instance.createEIP712(publicKey, contractaddress);
    const signature = await signer.signTypedData(eip712.domain, { Reencrypt: eip712.types.Reencrypt }, eip712.message);

    const aaveAdapter = (await ethers.getContractAt(
      "AaveConfidentialityAdapter",
      contractaddress,
      signer,
    )) as unknown as AaveConfidentialityAdapter;

    const encryptedBalance = await aaveAdapter.scaledBalances(signer.address);

    console.info("Encrypted balance: ", encryptedBalance);

    const userBalance: bigint = await instance.reencrypt(
      encryptedBalance, // the encrypted balance
      privateKey, // the private key generated by the dApp
      publicKey, // the public key generated by the dApp
      signature, // the user's signature of the public key
      contractaddress, // The contract address where the ciphertext is
      signer.address, // The user address where the ciphertext is
    );

    const aavePool = await ethers.getContractAt(Pool.abi, addresses[+chainId].AAVE_POOL, signer);

    const normalizedBalance: bigint = await aavePool.getReserveNormalizedIncome(asset);
    const suppliedBalance = (userBalance * normalizedBalance) / BigInt(1e27);

    console.info("Supplied balance: ", suppliedBalance);
  });
