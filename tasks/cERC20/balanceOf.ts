import { createInstance as createFhevmInstance } from "fhevmjs";
import { task } from "hardhat/config";

import addresses from "../../config/addresses";
import { GATEWAY_URL } from "../../config/constants";
import { CUSDC } from "../../types";

task("balanceOf", "Get user balance")
  .addParam("signeraddress", "signer address")
  .addParam("tokenaddress", "cERC20 contract address")
  .addOptionalParam("address", "User Address")
  .setAction(async ({ signeraddress, tokenaddress, address }, hre) => {
    const { ethers, getChainId } = hre;
    const chainId = await getChainId();
    const signer = await ethers.getSigner(signeraddress);

    if (!addresses[+chainId]) {
      throw new Error("Chain ID not supported");
    }

    if (!address) {
      address = signer.address;
    }

    const instance = await createFhevmInstance({
      kmsContractAddress: addresses[+chainId].KMSVERIFIER,
      aclContractAddress: addresses[+chainId].ACL,
      networkUrl: hre.network.config.url,
      gatewayUrl: GATEWAY_URL,
    });

    const { publicKey, privateKey } = instance.generateKeypair();
    const eip712 = instance.createEIP712(publicKey, tokenaddress);
    const signature = await signer.signTypedData(eip712.domain, { Reencrypt: eip712.types.Reencrypt }, eip712.message);

    const cerc20 = (await ethers.getContractAt("cUSDC", tokenaddress, signer)) as unknown as CUSDC;

    const encryptedBalance = await cerc20.balanceOf(address);

    console.info("Encrypted balance: ", encryptedBalance);

    const userBalance = await instance.reencrypt(
      encryptedBalance, // the encrypted balance
      privateKey, // the private key generated by the dApp
      publicKey, // the public key generated by the dApp
      signature, // the user's signature of the public key
      tokenaddress, // The contract address where the ciphertext is
      signer.address, // The user address where the ciphertext is
    );

    console.log("Decrypted balance: ", userBalance);
  });
